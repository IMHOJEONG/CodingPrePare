- Float 기반 샘플 화면 레이아웃 구성

  - codepen.io 
    - 온라인으로 간단하게 HTML, CSS를 만들고

  ```css
  .left, .right{
      float:left;
  }
  ```

  - left, right에 해당하는 이 메뉴와 본문에 해당하는 내용들이 float

    - footer가 float를 떠 있다고 생각해서 밀고 자기가 그 자리를 차지하러 올라옴!
    - clear라는 걸로 인식을 해서 네 위에 있는 float나 이런 것들을 인식해봐
    - float:left 속성은 인식해서 올라가지 말라는 것

    ```css
    footer{
        background-color:#eee;
        clear:left;    
    }
    // clear:both도 마찬가지
    ```

    - 만약 상위 엘리먼트가 right로 돼있거나 left로 돼있거나 모두 인식해서 위로 올라가지 않음
    - clear:left를 주면 footer가 올라가지 않는 문제는 해결함
      - 그렇지만 width 값이 변경이 되어버림
      - 배경으로 준 #wrap의 background-color가 나타나지 않는 문제 발생
      - 개발자도구 확인 해보면 computed 값이 0 
    - 자식이 float인 경우네는 자기의 자식으로 생각하지 않음
      - 왜? 둥 떠있기 때문에 float 속성을 자식으로 인정을 해서 높이값으로 생각하지 않음
        - overflow라는 속성을 줘서 float를 인식하게 할 수 있음
        - float랑 사실은 overflow와 관계는 굉장히 이해하기 어려울 수 있음
        - overflow 속성을 줬을 때는 float를 인식을 하게 되어 있어 (부모 입장에서)
          - 매우 힘들지만, 우리가 낯선 부분
          - overflow:auto, overflow:hidden을 주어서 해결 가능
      - 정리
        - left, right를 주고 float를 주고 그 다음에 wrap에다가 overflow를 줘서 자식으로 인식을 시킴
      - margin 값으로 서로 간격을 띄워보자
      - 좌우의 기본 높이를 맞추는 것은 매우 쉬움 
      - position이 static이라 absolute의 기준이 되지 않는다.
        - position:relative를 주어도 top, left를 주지 않으면 그대로
      - 저장을 하고 .right에, 이거 바로 자손이기 때문에 .right .emoticon으로 해야함
      - float, position을 잘 조절해서 하면 됨

- 디버깅-HTML-CSS

  - 프로그래밍의 디버깅이 꽤 중요

  - HTML/CSS를 개발하면서 생가는 문제를 어떻게 빨리 처리해야 할까?

  - 더 빠르고 정확한 문제를 해결하기 위한 HTML, CSS 디버깅 방법을 공부

  - debugging, chrome developer tools

  - Chrome 개발자 도구

    - Elements 탭	

      - HTML와 CSS를 개발할 때 반드시 알아둬야 함

      - cmd + +,-로 화면 확대, 축소도 가능함

      - Inspect 한다 => 해당하는 element 클릭하면 원하는 속성을 알 수 있음

      - 주의 깊게 봐야될 것 

        - 이 엘리먼트가 어떤 HTML의 구조 안에 존재하는지 알 수 있고 

        - 하단에 보면 이 녀석이 가지는 DOM 노드의 순서가 나옴

          - DOM 노드 

            - 어떤 계층 구조를 가지고 있기 때문에, 어느 태그의 어느 쪽 아래에 있느냐를 정확히 알 수가 있음
            - 그래서 HTML 정보는 이걸로 우리가 파악 가능
            - 눌렀을 때 오른쪽에 보면 이 엘리먼트가 가지고 있는 스타일 정보가 쭉 나타남

          - 종합된, 최종적으로 가지고 있는 스타일 정보는 Computed 항목에 보면 나옴

            - 디폴트로 가지고 있는 속성을 제외하고 어떤 사용자가 지정한 정보가 있고
            - show all을 하면 기본적으로 가지고 있는 정보까지 모두 다 나타남

          - 스타일 정보

            - 브라우저가 CSS를 파악을 한 다음에  어떻게 얘가 파악을 했는지에 대한 정보를 나타낸다고 볼 수 있음
            - 어떻게 파악을 했는가? 
              - 즉 소스코드 레벨로 네가 어느 라인의 어떤 부분을 짠 부분 때문에 ~가 이거야 라는 느낌 
            - 순서와 상관없더라도 셀렉터에 보면 우선순위라는 게 존재함
            - 셀렉터에 점수를 줄 수 있음 
              - 그 점수에 따라서 id는 100점, class 10점
              - 그 점수가 높은 거를 얘가 이제 나 이게 있었는데 나 이거 무시했고 내가 CSS를 처리하는 과정에서 얘를 무시했고 
              - 이 값을 반영을 했어라는 것을 디버깅하게 좋게 얘가 보여주는 것
              - Computed에 가서 특정 속성 클릭해보면 이게 왜 취소가 됐는지를 이렇게 많은 정보를 알 수가 있음

          - #666 -> #666666과 같음, 똑같기 때문에 생략함

            - 16진수 표기법으로 red,green, blue로 표시 가능

          - color 값과 같은 일반적인 CSS 스타일은 상속을 받을 수가 있음

          - 보통 박스 모델에 해당하는 margin, padding 이런 배치 관련된 것들은 상속받지 않음

            - 그걸 모두 배치받으면 간격을, 부모가 가진 간격도 얘가 먹으면서 좀 이상해지겠지? 배치 조정이 굉장히 어려워짐
            - 스타일 조정은 상속을 받음 
            - inline - HTML 안에 스타일 정보로 들어감
              - header 태그 안에 스타일 정보를 넣는 것, 외부에 CSS 파일을 넣는 것보다 먼저 우선 돼어서 반영이 됨
            - Color picker로 원하는 색깔 반영 가능
            - 왜 취소되었는지, 상속 받았는지 알 수 있음

          - 새로운 룰을 만들겠다?

            - `+`버튼을 활용해서 추가 가능
            - 새로운 룰 테스트 가능
            - inspector-stylesheet라고 해서 개발자 도구에서만 쓸 수 있는 임시의 영역에다가 저장을 해서 이렇게 화면에 표시해주고 있음
            - JS도 제어 가능, Delete Element, hover, Hide Element도 가능

          - Computed 최종 연산된 것, Styled - 스타일 정보

          - 자동 완성이 되기 때문에 손쉽게 바꿀 수 있음

            

